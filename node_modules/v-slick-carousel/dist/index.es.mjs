var xt = Object.defineProperty;
var Lt = (e, r, t) => r in e ? xt(e, r, { enumerable: !0, configurable: !0, writable: !0, value: t }) : e[r] = t;
var Ue = (e, r, t) => Lt(e, typeof r != "symbol" ? r + "" : r, t);
import { defineComponent as ye, computed as A, unref as Se, renderSlot as oe, normalizeProps as ue, mergeProps as ae, createElementVNode as se, normalizeClass as de, toDisplayString as be, openBlock as O, createElementBlock as D, normalizeStyle as Me, Fragment as Q, renderList as Z, createBlock as ie, resolveDynamicComponent as xe, useSlots as Ct, ref as q, getCurrentInstance as It, watch as K, onMounted as bt, onUpdated as Mt, onBeforeUnmount as Et, withCtx as Le, guardReactiveProps as Ce, createCommentVNode as Ie, createVNode as Ot } from "vue";
var k = /* @__PURE__ */ ((e) => (e.play = "play", e.playing = "playing", e.paused = "paused", e.hovered = "hovered", e.focused = "focused", e.update = "update", e.leave = "leave", e.blur = "blur", e))(k || {}), et = /* @__PURE__ */ ((e) => (e.ondemand = "ondemand", e.progressive = "progressive", e))(et || {}), N = /* @__PURE__ */ ((e) => (e.left = "left", e.right = "right", e.up = "up", e.down = "down", e.vertical = "vertical", e))(N || {}), P = /* @__PURE__ */ ((e) => (e.next = "next", e.previous = "previous", e))(P || {}), le = /* @__PURE__ */ ((e) => (e.auto = "auto", e.manual = "manual", e))(le || {});
const Ee = (e) => e.flatMap(
  (r) => $t(r) ? [r] : Array.isArray(r.children) && r.children.length > 0 ? Ee(r.children) : []
);
function $t(e) {
  return !e.type.toString().startsWith("Symbol");
}
const zt = (e, r, t) => {
  var s;
  return (s = e.target) != null && s.tagName.match("TEXTAREA|INPUT|SELECT") || !r ? "" : e.key === "ArrowLeft" ? t ? P.next : P.previous : e.key === "ArrowRight" ? t ? P.previous : P.next : "";
}, Wt = (e, r) => {
  let t, s, n, d, a;
  const {
    groupsToScroll: m,
    groupsToShow: T,
    slideGroupCount: f,
    currentSlideGroupIndex: p,
    lazyLoad: c,
    infinite: w
  } = e;
  if (d = f % m !== 0, t = d ? 0 : (f - p) % m, r.message === P.previous)
    n = t === 0 ? m : T - t, a = p - n, c && !w && (s = p - n, a = s === -1 ? f - 1 : s);
  else if (r.message === P.next)
    n = t === 0 ? m : t, a = p + n, c && !w && (a = (p + m) % f + t);
  else if (r.message === "dots") {
    if (a = (r.index || 0) * m, a === p)
      return null;
  } else if (r.message === "children") {
    if (a = r.index || 0, a === p)
      return null;
    if (w) {
      let y = Dt({ ...e, targetSlideGroupIndex: a });
      a > p && y === "left" ? a = a - f : a < p && y === "right" && (a = a + f);
    }
  } else if (r.message === "index" && (a = Number(r.index), a === p))
    return null;
  return a;
}, Dt = (e) => e.targetSlideGroupIndex > e.currentSlideGroupIndex ? e.targetSlideGroupIndex > e.currentSlideGroupIndex + Nt(e) ? "left" : "right" : e.targetSlideGroupIndex < e.currentSlideGroupIndex - Pt(e) ? "right" : "left", Nt = ({
  groupsToShow: e,
  centerMode: r,
  rtl: t,
  centerPadding: s
}) => {
  if (r) {
    let n = (e - 1) / 2 + 1;
    return parseInt(s) > 0 && (n += 1), t && e % 2 === 0 && (n += 1), n;
  }
  return t ? 0 : e - 1;
}, Pt = ({
  groupsToShow: e,
  centerMode: r,
  rtl: t,
  centerPadding: s
}) => {
  if (r) {
    let n = (e - 1) / 2 + 1;
    return parseInt(s) > 0 && (n += 1), !t && e % 2 === 0 && (n += 1), n;
  }
  return t ? e - 1 : 0;
}, At = (e) => {
  let r = e.infinite ? e.slideGroupCount * 2 : e.slideGroupCount, t = e.infinite ? e.groupsToShow * -1 : 0, s = e.infinite ? e.groupsToShow * -1 : 0, n = [];
  for (; t < r; )
    n.push(t), t = s + e.groupsToScroll, s += Math.min(e.groupsToScroll, e.groupsToShow);
  return n;
}, Ke = (e, r) => {
  const t = At(e);
  let s = 0;
  if (r > t[t.length - 1])
    r = t[t.length - 1];
  else
    for (let n in t) {
      if (r < t[n]) {
        r = s;
        break;
      }
      s = t[n];
    }
  return r;
}, Ht = (e, r, t) => {
  if (!(!r || !t && e.type.indexOf("mouse") !== -1))
    return {
      dragging: !0,
      touchObject: {
        startX: window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageX : e.clientX,
        startY: window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageY : e.clientY,
        curX: window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageX : e.clientX,
        curY: window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageY : e.clientY
      }
    };
}, Qe = (e) => {
  var T;
  const r = e.centerMode ? +e.slideGroupWidth * Math.floor(e.groupsToShow / 2) : 0;
  let t;
  const n = e.listEl.querySelectorAll(
    ".v-slick-slide-group"
  );
  if (Array.from(n).every((f) => {
    if (e.vertical) {
      if (f.offsetTop + f.offsetHeight / 2 > e.swipeLeft * -1)
        return t = f, !1;
    } else if (f.offsetLeft - r + f.offsetWidth / 2 > e.swipeLeft * -1)
      return t = f, !1;
    return !0;
  }), !t)
    return 0;
  const d = e.rtl === !0 ? e.slideGroupCount - e.currentSlideGroupIndex : e.currentSlideGroupIndex, a = (T = t == null ? void 0 : t.dataset) == null ? void 0 : T.index;
  return Math.abs(
    a ? parseInt(a) : 0 - d
  );
}, tt = (e, r = !1) => {
  let t, s, n, d;
  return t = e.startX - e.curX, s = e.startY - e.curY, n = Math.atan2(s, t), d = Math.round(n * 180 / Math.PI), d < 0 && (d = 360 - Math.abs(d)), d <= 45 && d >= 0 || d <= 360 && d >= 315 ? N.left : d >= 135 && d <= 225 ? N.right : r === !0 ? d >= 35 && d <= 135 ? N.up : N.down : N.vertical;
}, Bt = (e, r) => {
  const {
    dragging: t,
    swipe: s,
    touchObject: n,
    listWidth: d,
    touchThreshold: a,
    verticalSwiping: m,
    listHeight: T,
    currentSlideGroupIndex: f,
    swipeToSlide: p,
    scrolling: c,
    onSwipe: w,
    rtl: y
  } = r;
  if (!t) {
    s && e.preventDefault();
    return;
  }
  let S = m ? T / a : d / a, x = tt(n, m);
  y && (x === N.left ? x = N.right : x === N.right && (x = N.left));
  let E = {
    dragging: !1,
    edgeDragged: !1,
    scrolling: !1,
    swiping: !1,
    swiped: !1,
    swipeLeft: null,
    touchObject: {}
  };
  if (c || !n.swipeLength)
    return E;
  if (n.swipeLength > S) {
    e.preventDefault(), w && w(x);
    let G, I;
    switch (x) {
      case "left":
      case "up":
        I = r.swipeToSlide ? Qe(r) : f + r.groupsToScroll, G = p ? Ke(r, I) : I, E.currentDirection = 0;
        break;
      case "right":
      case "down":
        I = r.swipeToSlide ? Qe(r) : f - r.groupsToScroll, G = p ? Ke(r, I) : I, E.currentDirection = 1;
        break;
      default:
        G = f;
    }
    E.triggerSlideGroupHandler = G;
  } else {
    let G = fe(r);
    E.trackStyle = ot(r, G);
  }
  return E;
};
function Rt(e) {
  return e.centerMode ? Math.floor(e.groupsToShow / 2) + (parseInt(e.centerPadding) > 0 ? 1 : 0) : 0;
}
function Vt(e) {
  return e.centerMode ? Math.floor((e.groupsToShow - 1) / 2) + 1 + (parseInt(e.centerPadding) > 0 ? 1 : 0) : e.groupsToShow;
}
function rt(e) {
  return e.currentSlideGroupIndex - Rt(e);
}
function lt(e) {
  return e.currentSlideGroupIndex + Vt(e);
}
function ze(e) {
  var n;
  let r = [];
  const t = rt(e), s = lt(e);
  for (let d = t; d < s; d++)
    ((n = e.lazyLoadedList) == null ? void 0 : n.indexOf(d)) < 0 && r.push(d);
  return r;
}
function ce(e, r) {
  let t, s;
  const n = e.slideGroupCount + 2 * e.groupsToShow;
  e.vertical ? s = n * parseInt(`${e.slideGroupHeight || 0}`) : t = _t(e) * parseInt(`${e.slideGroupWidth || 0}`);
  let d = {
    opacity: 1,
    transition: ""
  };
  if (e.useCSSTransform) {
    let a = e.vertical ? "translate3d(0px, " + r + "px, 0px)" : "translate3d(" + r + "px, 0px, 0px)";
    d = {
      ...d,
      transform: a
    };
  } else
    e.vertical ? d.top = r : d.left = r;
  return e.fade && (d = { opacity: 1 }), t && (d.width = t + "px"), s && (d.height = s + "px"), d;
}
function _t(e) {
  return e.slideGroupCount <= e.groupsToShow ? e.slideGroupCount : J(e) + e.slideGroupCount + Oe(e);
}
function ot(e, r) {
  let t = ce(e, r);
  return e.useCSSTransform ? t.transition = "transform " + e.speed + "ms " + e.cssEase : e.vertical ? t.transition = "top " + e.speed + "ms " + e.cssEase : t.transition = "left " + e.speed + "ms " + e.cssEase, e.ignorePrefersReducedMotion && (t.transition += " !important"), t;
}
function fe(e) {
  let {
    centerPadding: r,
    currentSlideGroupIndex: t,
    trackEl: s,
    infinite: n,
    centerMode: d,
    slideGroupCount: a,
    groupsToShow: m,
    groupsToScroll: T,
    slideGroupWidth: f,
    listWidth: p,
    variableWidth: c,
    slideGroupHeight: w,
    fade: y,
    vertical: S,
    rtl: x
  } = e;
  p = p || 0, f = f || 0, w = w || 0;
  let E = 0, G, I, V = 0;
  if (y || a === 1)
    return 0;
  let H = 0;
  if (n ? (H = -J(e), a % T !== 0 && t + T > a && (H = -(t > a ? m - (t - a) : a % T)), d && (H += Math.floor(m / 2))) : (a % T !== 0 && t + T > a && (H = m - a % T), d && (H = Math.floor(m / 2))), E = H * parseInt(`${f}`), V = H * parseInt(`${w}`), S ? G = t * parseInt(`${w}`) * -1 + V : G = t * parseInt(`${f}`) * -1 + E, c === !0) {
    let W;
    if (W = t + J(e), I = s && s.childNodes[W], G = I ? I.offsetLeft * -1 : 0, d === !0) {
      if (W = n ? t + J(e) : t, G = 0, s) {
        I = s.children[W];
        for (let z = 0; z < W; z++)
          s.children[z] && (G -= s.children[z].offsetWidth);
      }
      G -= parseInt(r), I && (G += p - I.offsetWidth / 2);
    }
  }
  return x && (G = -G), G;
}
const jt = (e) => e.infinite || e.currentSlideGroupIndex !== 0 && e.slideGroupCount > e.groupsToShow, We = (e) => {
  let r = !0;
  return e.infinite || (e.centerMode ? r = e.currentSlideGroupIndex < e.slideGroupCount - 1 : (e.slideGroupCount <= e.groupsToShow || e.currentSlideGroupIndex >= e.slideGroupCount - e.groupsToShow) && (r = !1)), r;
}, Xt = (e) => {
  let {
    waitForAnimate: r,
    animating: t,
    fade: s,
    infinite: n,
    index: d,
    slideGroupCount: a,
    lazyLoadedList: m,
    lazyLoad: T,
    currentSlideGroupIndex: f,
    centerMode: p,
    groupsToScroll: c,
    groupsToShow: w,
    useCSSTransitions: y
  } = e;
  if (r && t || s && !n && (d < 0 || d >= a))
    return;
  let S = d, x, E = {}, G = {};
  if (s)
    return d < 0 ? S += a : d >= a && (S -= a), T && m.indexOf(S) < 0 && m.push(S), E = {
      animating: !0,
      currentSlideGroupIndex: S,
      lazyLoadedList: m
    }, G = { animating: !1 }, {
      slidingState: E,
      afterSlidingState: G
    };
  x = S, S < 0 ? (x = S + a, n ? a % c !== 0 && (x = a - a % c) : x = 0) : !We(e) && S > f ? S = x = f : p && S >= a ? (S = n ? a : a - 1, x = n ? 0 : a - 1) : S >= a && (x = S - a, n ? a % c !== 0 && (x = 0) : x = a - w);
  let I = fe({
    ...e,
    currentSlideGroupIndex: x
  }), V = fe({
    ...e,
    currentSlideGroupIndex: S
  });
  return n || (V === I && (S = x), V = I), T && (m = m.concat(
    ze({
      ...e,
      currentSlideGroupIndex: S
    })
  )), y ? (E = {
    animating: !0,
    currentSlideGroupIndex: x,
    trackStyle: ot(e, V),
    lazyLoadedList: m
  }, G = {
    animating: !1,
    currentSlideGroupIndex: x,
    trackStyle: ce(e, I),
    swipeLeft: void 0
  }, { slidingState: E, afterSlidingState: G }) : (E = {
    currentSlideGroupIndex: x,
    trackStyle: ce(e, I),
    lazyLoadedList: m
  }, {
    slidingState: E,
    afterSlidingState: G
  });
};
function J(e) {
  return e.infinite ? e.variableWidth ? e.slideGroupCount : e.groupsToShow + (e.centerMode ? 1 : 0) : 0;
}
function Oe(e) {
  return e.infinite ? e.slideGroupCount : 0;
}
const Yt = (e, r) => {
  const {
    scrolling: t,
    animating: s,
    vertical: n,
    swipeToSlide: d,
    verticalSwiping: a,
    rtl: m,
    currentSlideGroupIndex: T,
    edgeFriction: f,
    edgeDragged: p,
    onEdge: c,
    swiped: w,
    swiping: y,
    slideGroupCount: S,
    groupsToScroll: x,
    infinite: E,
    touchObject: G,
    swipeEvent: I,
    listHeight: V,
    listWidth: H
  } = r;
  if (t) return;
  if (s) {
    e.preventDefault();
    return;
  }
  n && d && a && e.preventDefault();
  let W, z = {}, R = fe(r);
  G.curX = window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageX : e.clientX, G.curY = window.TouchEvent && e instanceof TouchEvent ? e.touches[0].pageY : e.clientY, G.swipeLength = Math.round(
    Math.sqrt(Math.pow(G.curX - G.startX, 2))
  );
  let _ = Math.round(
    Math.sqrt(Math.pow(G.curY - G.startY, 2))
  );
  if (!a && !y && _ > 10)
    return { scrolling: !0 };
  a && (G.swipeLength = _);
  let j = (m ? -1 : 1) * (G.curX > G.startX ? 1 : -1);
  a && (j = G.curY > G.startY ? 1 : -1);
  let Ge = Math.ceil(S / x), X = tt(r.touchObject, a), F = G.swipeLength;
  return E || (T === 0 && X === "right" || T + 1 >= Ge && X === "left" || !We(r) && X === "left") && (F = Math.round(G.swipeLength * f), p === !1 && c && (c(X), z.edgeDragged = !0)), !w && I && (I(X), z.swiped = !0), n ? W = R + F * (V / H) * j : m ? W = R - F * j : W = R + F * j, a && (W = R + F * j), z = {
    ...z,
    touchObject: G,
    swipeLeft: W,
    trackStyle: ce(r, W),
    swipeDirection: X
  }, Math.abs(G.curX - G.startX) < Math.abs(G.curY - G.startY) * 0.8 || G.swipeLength > 10 && (z.swiping = !0, e.preventDefault()), z;
};
function it(e, r) {
  return Math.ceil(e / r);
}
function qt(e) {
  var c, w, y;
  let r = it(
    e.slides.length,
    e.groupsToShow
  ), t = Math.ceil(((c = e.listEl) == null ? void 0 : c.offsetWidth) || 0), s = Math.ceil(((w = e.trackEl) == null ? void 0 : w.offsetWidth) || 0), n;
  if (e.vertical)
    n = t;
  else {
    let S = e.centerMode ? parseInt(e.centerPadding) * 2 : 0;
    typeof e.centerPadding == "string" && e.centerPadding.slice(-1) === "%" && (S *= t / 100), n = Math.ceil(
      (t - S) / e.groupsToShow
    );
  }
  let d = e.listEl && e.listEl.querySelector('[data-index="0"]') && ((y = e.listEl.querySelector('[data-index="0"]')) == null ? void 0 : y.offsetHeight) || 0, a = d * e.groupsToShow, m = e.currentSlideGroupIndex === void 0 ? e.initialGroupIndex : e.currentSlideGroupIndex;
  e.rtl && e.currentSlideGroupIndex === void 0 && (m = r - 1 - e.initialGroupIndex);
  let T = e.lazyLoadedList || [], f = ze(e);
  T.concat(f);
  let p = {
    slideGroupCount: r,
    slideGroupWidth: n,
    listWidth: t,
    trackWidth: s,
    currentSlideGroupIndex: m,
    slideGroupHeight: d,
    listHeight: a,
    lazyLoadedList: T
  };
  return e.autoplaying === null && e.autoplay && (p.autoplaying = k.playing), p;
}
class Ft {
  constructor() {
    Ue(this, "mqlRecords", {});
  }
  register(r, t) {
    this.mqlRecords[r] ? this.addMqlListener(r, t) : (this.mqlRecords[r] = window.matchMedia(r), this.addMqlListener(r, t)), this.mqlRecords[r].matches && t({ matches: !0 });
  }
  unregister(r, t) {
    this.mqlRecords[r] && this.removeMqlListener(r, t);
  }
  addMqlListener(r, t) {
    try {
      this.mqlRecords[r].addEventListener("change", t);
    } catch {
      try {
        this.mqlRecords[r].addListener(t);
      } catch (n) {
        console.error(n);
      }
    }
  }
  removeMqlListener(r, t) {
    try {
      this.mqlRecords[r].removeEventListener("change", t);
    } catch {
      try {
        this.mqlRecords[r].removeListener(t);
      } catch (n) {
        console.error(n);
      }
    }
  }
}
const Ut = () => !!(typeof window < "u" && window.document && window.document.createElement), Ze = (e) => Object.keys(e).filter((r) => e[r] !== void 0).reduce((r, t) => (r[t] = e[t], r), {});
function Kt() {
  var e, r;
  window.getSelection && ((e = window.getSelection()) != null && e.empty ? window.getSelection().empty() : (r = window.getSelection()) != null && r.removeAllRanges && window.getSelection().removeAllRanges());
}
function Qt(e) {
  return Object.keys(e).map((t) => {
    let s = e[t];
    return Array.isArray(s) && (s = s.join(" and ")), `(${t}: ${s})`;
  }).join(" and ");
}
function Zt(e, r) {
  const t = setTimeout(e, r);
  return { cancel: () => clearTimeout(t) };
}
const we = (e) => {
  const r = {
    accessibility: { type: Boolean, default: !0 },
    adaptiveHeight: { type: Boolean, default: !1 },
    arrows: { type: Boolean, default: !0 },
    asNavFor: {
      type: Object,
      default: null
    },
    autoplay: { type: Boolean, default: !1 },
    autoplaySpeed: { type: Number, default: 3e3 },
    centerMode: { type: Boolean, default: !1 },
    centerPadding: { type: String, default: "50px" },
    cssEase: { type: String, default: "ease" },
    dots: { type: Boolean, default: !1 },
    draggable: { type: Boolean, default: !0 },
    edgeFriction: { type: Number, default: 0.35 },
    fade: { type: Boolean, default: !1 },
    focusOnSelect: { type: Boolean, default: !1 },
    ignorePrefersReducedMotion: { type: Boolean, default: !1 },
    infinite: { type: Boolean, default: !0 },
    initialGroupIndex: { type: Number, default: 0 },
    lazyLoad: { type: String, default: null },
    nextArrowLabel: { type: String, default: "Next" },
    pauseOnDotsHover: { type: Boolean, default: !1 },
    pauseOnFocus: { type: Boolean, default: !1 },
    pauseOnHover: { type: Boolean, default: !0 },
    prevArrowLabel: { type: String, default: "Previous" },
    responsive: { type: Array, default: [] },
    rtl: { type: Boolean, default: !1 },
    slidesPerGroup: { type: Number, default: 1 },
    groupsToScroll: { type: Number, default: 1 },
    groupsToShow: { type: Number, default: 1 },
    speed: { type: Number, default: 500 },
    swipe: { type: Boolean, default: !0 },
    swipeToSlide: { type: Boolean, default: !1 },
    touchMove: { type: Boolean, default: !0 },
    touchThreshold: { type: Number, default: 5 },
    useCSSTransitions: { type: Boolean, default: !0 },
    useCSSTransform: { type: Boolean, default: !0 },
    variableWidth: { type: Boolean, default: !1 },
    vertical: { type: Boolean, default: !1 },
    verticalSwiping: { type: Boolean, default: !1 },
    waitForAnimate: { type: Boolean, default: !0 },
    widthDetection: { type: String, default: le.auto }
  };
  return e ? Object.keys(r).reduce((t, s) => (e.includes(s) && (t[s] = r[s]), t), {}) : r;
}, $e = we(), Jt = Object.keys($e).reduce((e, r) => (e[r] = $e[r].default, e), {}), er = () => ({
  animating: !1,
  autoplaying: null,
  autoplayTimer: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlideGroupIndex: 0,
  detectingWidth: !1,
  direction: 1,
  dragging: !1,
  edgeDragged: !1,
  initialized: !1,
  lazyLoadedList: [],
  listHeight: void 0,
  listWidth: void 0,
  scrolling: !1,
  slideGroupHeight: void 0,
  slideGroupWidth: void 0,
  swipeLeft: void 0,
  swiped: !1,
  swiping: !1,
  touchObject: { startX: 0, startY: 0, curX: 0, curY: 0, swipeLength: 0 },
  trackStyle: {},
  trackWidth: 0
}), tr = {
  ...we([
    "centerMode",
    "centerPadding",
    "cssEase",
    "fade",
    "ignorePrefersReducedMotion",
    "infinite",
    "lazyLoad",
    "rtl",
    "groupsToScroll",
    "groupsToShow",
    "speed",
    "variableWidth",
    "vertical"
  ]),
  currentSlideGroupIndex: { type: Number, default: 0 },
  detectingWidth: { type: Boolean, default: !1 },
  lazyLoadedList: {
    type: Array,
    default: []
  },
  listHeight: { type: Number, default: void 0 },
  trackStyle: { type: Object, default: {} },
  slideGroupCount: { type: Number, default: 0 },
  rawSlideGroups: { type: Array, default: [] },
  slideGroupHeight: { type: [String, Number], default: void 0 },
  slideGroupWidth: { type: [String, Number], default: void 0 }
}, rr = {
  ...we([
    "centerMode",
    "infinite",
    "groupsToShow",
    "prevArrowLabel",
    "nextArrowLabel"
  ]),
  currentSlideGroupIndex: { type: Number, default: 0 },
  disabled: { type: Boolean, default: !1 },
  slideGroupCount: { type: Number, default: 0 },
  type: { type: String, default: "prev" }
}, lr = {
  ...we(["infinite", "groupsToScroll", "groupsToShow"]),
  currentSlideGroupIndex: { type: Number, default: 0 },
  slideGroupCount: { type: Number, default: 0 },
  pageCount: { type: Number, default: 0 }
}, or = /* @__PURE__ */ ye({
  __name: "VSlickArrow",
  props: rr,
  emits: [P.previous, P.next],
  setup(e, { emit: r }) {
    const t = e, s = r, n = A(() => () => {
      t.disabled || s(t.type);
    }), d = A(() => ({
      currentSlideGroupIndex: t.currentSlideGroupIndex,
      slideGroupCount: t.slideGroupCount,
      onClick: n.value,
      disabled: !t.disabled
    }));
    return (a, m) => a.type === Se(P).previous ? oe(a.$slots, "prevArrow", ue(ae({ key: 0 }, d.value)), () => [
      se("button", {
        type: "button",
        "data-role": "none",
        class: de(["v-slick-arrow prev", { disabled: a.disabled }]),
        onClick: m[0] || (m[0] = //@ts-ignore
        (...T) => n.value && n.value(...T))
      }, be(a.prevArrowLabel), 3)
    ], !0) : oe(a.$slots, "nextArrow", ue(ae({ key: 1 }, d.value)), () => [
      se("button", {
        type: "button",
        "data-role": "none",
        class: de(["v-slick-arrow next", { disabled: a.disabled }]),
        onClick: m[1] || (m[1] = //@ts-ignore
        (...T) => n.value && n.value(...T))
      }, be(a.nextArrowLabel), 3)
    ], !0);
  }
}), De = (e, r) => {
  const t = e.__vccOpts || e;
  for (const [s, n] of r)
    t[s] = n;
  return t;
}, Je = /* @__PURE__ */ De(or, [["__scopeId", "data-v-1ed7a297"]]), ir = ["onClick"], nr = ["onClick"], ur = ["onClick"], ar = /* @__PURE__ */ ye({
  __name: "VSlickTrack",
  props: tr,
  emits: ["childClick"],
  setup(e, { emit: r }) {
    const t = e, s = r, n = (f) => {
      let p = !1, c = !1, w = !1, y;
      return t.centerMode ? (y = Math.floor(t.groupsToShow / 2), c = (f - t.currentSlideGroupIndex) % t.slideGroupCount === 0, f > t.currentSlideGroupIndex - y - 1 && f <= t.currentSlideGroupIndex + y && (p = !0)) : p = t.currentSlideGroupIndex <= f && f < t.currentSlideGroupIndex + t.groupsToShow, w = f === t.currentSlideGroupIndex, Object.entries({
        active: p,
        center: c,
        current: w
      }).filter(([, S]) => S).map(([S]) => S);
    }, d = (f) => {
      let p = {};
      if ((t.variableWidth === void 0 || t.variableWidth === !1) && (p.width = typeof t.slideGroupWidth == "number" ? `${t.slideGroupWidth}px` : t.slideGroupWidth), t.fade) {
        if (p.position = "relative", t.vertical) {
          const c = t.slideGroupHeight ? typeof t.slideGroupHeight == "string" ? parseFloat(t.slideGroupHeight) : t.slideGroupHeight : 0;
          p.top = `${-f * c}px`;
        } else {
          const c = t.slideGroupWidth ? typeof t.slideGroupWidth == "string" ? parseFloat(t.slideGroupWidth) : t.slideGroupWidth : 0, w = t.rtl ? f * c : -f * c;
          p.left = `${w}px`;
        }
        p.opacity = t.currentSlideGroupIndex === f ? 1 : 0, p.transition = "opacity " + t.speed + "ms " + t.cssEase + ", visibility " + t.speed + "ms " + t.cssEase, t.ignorePrefersReducedMotion && (p.transition += " !important");
      }
      return p;
    }, a = A(() => t.rawSlideGroups.map((p, c) => {
      const w = d(c), y = n(c);
      t.fade && y.includes("active") && Object.assign(w, { zIndex: 1 });
      const S = {
        slides: [],
        key: `original-${c}`,
        class: y,
        style: w,
        attrs: {
          "data-index": c,
          "aria-hidden": `${!y.includes("active")}`
        },
        onClick: () => {
          s("childClick", {
            index: t.rtl && t.infinite ? t.slideGroupCount + c : c
          });
        }
      };
      return (!t.lazyLoad || t.lazyLoad && t.lazyLoadedList.indexOf(c) >= 0) && (S.slides = p), S;
    })), m = A(() => !t.infinite || t.fade || t.slideGroupCount <= t.groupsToShow ? [] : t.rawSlideGroups.map((p, c) => {
      const w = t.slideGroupCount - c;
      if (w > J(t)) return;
      const y = -w, S = {
        slides: [],
        key: `preclone-${y}`,
        class: n(y),
        style: d(c),
        attrs: {
          "data-index": y,
          "aria-hidden": "true"
        },
        onClick: () => {
          s("childClick", {
            index: y
          });
        }
      };
      return (y >= rt(t) || !t.lazyLoad || t.lazyLoad && t.lazyLoadedList.indexOf(c) >= 0) && (S.slides = p), S;
    }).filter((p) => p)), T = A(() => !t.infinite || t.fade || t.slideGroupCount <= t.groupsToShow ? [] : t.rawSlideGroups.map((p, c) => {
      const w = t.slideGroupCount + c, y = {
        slides: [],
        key: `postclone-${w}`,
        class: n(w),
        style: d(c),
        attrs: {
          "data-index": w,
          "aria-hidden": t.infinite && t.slideGroupCount - t.currentSlideGroupIndex < t.groupsToShow && c < t.groupsToShow - (t.slideGroupCount - t.currentSlideGroupIndex) ? "false" : "true"
        },
        onClick: () => {
          s("childClick", {
            index: t.rtl ? t.slideGroupCount + w : w
          });
        }
      };
      return (w < lt(t) || !t.lazyLoad || t.lazyLoad && t.lazyLoadedList.indexOf(c) >= 0) && (y.slides = p), y;
    }));
    return (f, p) => (O(), D("div", {
      class: de(["v-slick-track", { center: f.centerMode, vertical: f.vertical }]),
      style: Me([f.trackStyle, f.detectingWidth ? { width: "0 !important" } : {}])
    }, [
      (O(!0), D(Q, null, Z(m.value, (c, w) => (O(), D("div", ae({
        key: c.key,
        tabindex: "-1",
        class: [c.class, "v-slick-slide-group clone"],
        style: c.style,
        ref_for: !0
      }, c.attrs, {
        onClick: c.onClick
      }), [
        (O(!0), D(Q, null, Z(c.slides, (y, S) => (O(), ie(xe(y), {
          key: `slide-${w}-${S}` + (y.key ? `-${String(y.key)}` : "")
        }))), 128))
      ], 16, ir))), 128)),
      (O(!0), D(Q, null, Z(a.value, (c, w) => (O(), D("div", ae({
        key: c.key,
        tabindex: "-1",
        class: ["v-slick-slide-group", c.class],
        style: c.style,
        ref_for: !0
      }, c.attrs, {
        onClick: c.onClick
      }), [
        (O(!0), D(Q, null, Z(c.slides, (y, S) => (O(), ie(xe(y), {
          key: `slide-${w}-${S}` + (y.key ? `-${String(y.key)}` : "")
        }))), 128))
      ], 16, nr))), 128)),
      (O(!0), D(Q, null, Z(T.value, (c, w) => (O(), D("div", ae({
        key: c.key,
        tabindex: "-1",
        class: [c.class, "v-slick-slide-group clone"],
        style: c.style,
        ref_for: !0
      }, c.attrs, {
        onClick: c.onClick
      }), [
        (O(!0), D(Q, null, Z(c.slides, (y, S) => (O(), ie(xe(y), {
          key: `slide-${w}-${S}` + (y.key ? `-${String(y.key)}` : "")
        }))), 128))
      ], 16, ur))), 128))
    ], 6));
  }
}), sr = /* @__PURE__ */ De(ar, [["__scopeId", "data-v-7489cd78"]]), dr = ["onClick"], cr = /* @__PURE__ */ ye({
  __name: "VSlickDots",
  props: lr,
  emits: ["dotClick", "dotsOver", "dotsLeave"],
  setup(e) {
    const r = e, t = (s) => {
      const n = s * r.groupsToScroll, d = n + r.groupsToScroll - 1;
      return r.currentSlideGroupIndex >= n && r.currentSlideGroupIndex <= d;
    };
    return (s, n) => (O(), D("ul", {
      class: "v-slick-dots",
      style: { display: "block" },
      onMouseenter: n[0] || (n[0] = (d) => s.$emit("dotsLeave")),
      onMouseleave: n[1] || (n[1] = (d) => s.$emit("dotsLeave")),
      onMouseover: n[2] || (n[2] = (d) => s.$emit("dotsOver"))
    }, [
      (O(!0), D(Q, null, Z(s.pageCount, (d) => (O(), D("li", {
        key: d,
        class: de({ active: t(d - 1) }),
        onClick: (a) => s.$emit("dotClick", {
          index: d - 1,
          groupsToScroll: s.groupsToScroll
        })
      }, [
        oe(s.$slots, "customPaging", {
          page: d - 1
        }, () => [
          se("button", null, be(d), 1)
        ])
      ], 10, dr))), 128))
    ], 32));
  }
}), fr = ["dir"], pr = 50, vr = /* @__PURE__ */ ye({
  inheritAttrs: !1,
  __name: "VSlickCarousel",
  props: $e,
  emits: [
    "init",
    "beforeChange",
    "afterChange",
    "lazyLoad",
    "lazyLoadError",
    "reInit",
    "edge",
    "swipe"
  ],
  setup(e, { expose: r, emit: t }) {
    var Ye, qe, Fe;
    const s = e, n = t, d = Ct(), a = Ut() ? new Ft() : void 0;
    let m, T = null, f = null, p = [];
    const c = q({
      ...((Fe = (qe = (Ye = It()) == null ? void 0 : Ye.vnode) == null ? void 0 : qe.props) == null ? void 0 : Fe.style) || {}
    });
    let w = !0, y = null, S = null, x = [];
    const E = (l, o, v) => {
      if (!a) return;
      const h = (g) => {
        g.matches ? o() : v();
      };
      a.register(l, h), x.push({ query: l, handler: h });
    }, G = () => {
      x.forEach(
        ({ query: l, handler: o }) => a == null ? void 0 : a.unregister(l, o)
      ), x = [];
    }, I = () => {
      if (!s.responsive.length) return;
      const l = s.responsive.map((o) => o.breakpoint);
      l.sort((o, v) => o - v), l.forEach((o, v) => {
        const h = Qt({
          "min-width": `${o}px`
        });
        E(
          h,
          () => {
            pe.value = o;
          },
          () => {
            pe.value = v === 0 ? void 0 : l[v - 1];
          }
        );
      });
    }, V = (l) => {
      setTimeout(() => {
        l.preventDefault();
      });
      const o = Ht(
        l,
        i.value.swipe,
        i.value.draggable
      );
      Object.assign(u.value, o);
    }, H = (l) => {
      var g;
      const o = Bt(l, {
        ...i.value,
        ...u.value,
        trackEl: (g = Y.value) == null ? void 0 : g.$el,
        listEl: b.value,
        slideGroupIndex: u.value.currentSlideGroupIndex,
        slideGroupCount: M.value
      });
      if (!o) return;
      const { triggerSlideGroupHandler: v, ...h } = o;
      m = v, Object.assign(u.value, h), m !== void 0 && U(m);
    }, W = (l) => {
      var h;
      Kt();
      const { swipeDirection: o, ...v } = Yt(l, {
        ...i.value,
        ...u.value,
        trackEl: (h = Y.value) == null ? void 0 : h.$el,
        listEl: b.value,
        slideGroupIndex: u.value.currentSlideGroupIndex,
        slideGroupCount: M.value,
        onEdge: (g) => n("edge", g),
        swipeEvent: (g) => n("swipe", g)
      }) || {};
      (i.value.verticalSwiping && o === N.up || o === N.down || !i.value.verticalSwiping && o === N.left || o === N.right) && l.preventDefault(), v && (v.swiping && (w = !1), Object.assign(u.value, v));
    }, z = () => {
      let l;
      if (i.value.rtl)
        l = u.value.currentSlideGroupIndex - i.value.groupsToScroll;
      else if (Te.value)
        l = u.value.currentSlideGroupIndex + i.value.groupsToScroll;
      else
        return !1;
      U(l);
    }, R = (l = null) => {
      u.value.autoplayTimer && (clearInterval(u.value.autoplayTimer), u.value.autoplayTimer = null);
      const o = u.value.autoplaying;
      l === k.paused ? u.value.autoplaying = k.paused : l === k.focused && (o === k.hovered || o === k.playing) ? u.value.autoplaying = k.focused : o === k.playing ? u.value.autoplaying = k.hovered : o === null && (u.value.autoplaying = null);
    }, _ = (l) => {
      u.value.autoplayTimer && clearInterval(u.value.autoplayTimer);
      const o = u.value.autoplaying;
      if (l === k.update) {
        if (o === k.hovered || o === k.focused || o === k.paused)
          return;
      } else if (l === k.leave) {
        if (o === k.paused || o === k.focused)
          return;
      } else if (l === k.blur && (o === k.paused || o === k.hovered))
        return;
      u.value.autoplayTimer = setInterval(
        z,
        i.value.autoplaySpeed + 50
      ), u.value.autoplaying = k.playing;
    }, j = () => {
      if (i.value.adaptiveHeight && b.value) {
        const l = b.value.querySelectorAll(
          ".v-slick-slide-group.active"
        );
        let o = 0;
        l.forEach((v) => {
          o = Math.max(o, v.offsetHeight);
        }), b.value.style.height = o + "px";
      }
    }, Ge = () => {
      i.value.autoplay && R(k.hovered);
    }, X = () => {
      i.value.autoplay && u.value.autoplaying === k.hovered && _(k.leave);
    }, F = (l) => {
      w === !1 && (l.stopPropagation(), l.preventDefault()), w = !0;
    }, nt = ({ index: l }) => {
      i.value.focusOnSelect && ee({
        message: "children",
        index: l
      });
    }, ut = (l) => {
      if (!i.value.accessibility) return;
      const o = zt(
        l,
        i.value.accessibility,
        i.value.rtl
      );
      o && ee({ message: o });
    }, Ne = (l) => {
      if (!i.value.touchMove) return;
      const o = l.target;
      o != null && o.classList.contains("no-swipe") || V(l);
    }, me = (l) => {
      if (!u.value.dragging || !i.value.touchMove) return;
      const o = l.target;
      o != null && o.classList.contains("no-swipe") || W(l);
    }, Pe = (l) => {
      i.value.touchMove && H(l);
    }, Ae = (l) => {
      !u.value.dragging || !i.value.touchMove || H(l);
    }, He = () => {
      i.value.pauseOnHover && Ge();
    }, at = () => {
      i.value.pauseOnHover && X();
    }, st = () => {
      i.value.pauseOnDotsHover && i.value.autoplay && R(k.hovered);
    }, dt = () => {
      i.value.pauseOnDotsHover && i.value.autoplay && u.value.autoplaying === k.hovered && _(k.leave);
    }, ct = ({ index: l }) => {
      ee({
        message: "dots",
        index: l
      });
    }, ft = () => {
      ee({
        message: P.next
      });
    }, pt = () => {
      ee({
        message: P.previous
      });
    }, ee = (l, o = !1) => {
      const v = {
        ...i.value,
        ...u.value,
        slideGroupCount: M.value
      }, h = Wt(
        v,
        l
      );
      h != null && U(
        h,
        o === !0 ? !0 : void 0
      );
    }, U = async (l, o = !1) => {
      var he, ne;
      const { asNavFor: v, speed: h } = i.value, g = u.value.currentSlideGroupIndex, L = Xt({
        index: l,
        ...i.value,
        ...u.value,
        slideGroupCount: M.value,
        trackEl: (he = Y.value) == null ? void 0 : he.$el,
        useCSSTransitions: i.value.useCSSTransitions && !o
      });
      if (!L) return;
      const { slidingState: $, afterSlidingState: C } = L;
      n(
        "beforeChange",
        g,
        $.currentSlideGroupIndex
      );
      const B = ((ne = $.lazyLoadedList) == null ? void 0 : ne.filter(
        (re) => u.value.lazyLoadedList.indexOf(re) < 0
      )) || [];
      B.length && n("lazyLoad", B), Object.assign(u.value, $), v && v.goTo(l), C && await new Promise((re) => {
        T = setTimeout(() => {
          const { animating: kt, ...Tt } = C;
          (i.value.waitForAnimate || u.value.currentSlideGroupIndex === $.currentSlideGroupIndex) && Object.assign(u.value, Tt), p.push(
            setTimeout(() => {
              u.value.animating = kt || !1;
            })
          ), n("afterChange", $.currentSlideGroupIndex), T = null, re();
        }, h);
      });
    }, ke = (l) => {
      var L, $;
      const o = qt({
        ...i.value,
        ...u.value,
        listEl: b.value,
        trackEl: (L = Y.value) == null ? void 0 : L.$el,
        slides: ge.value
      }), v = {
        ...i.value,
        ...u,
        ...o,
        trackEl: ($ = Y.value) == null ? void 0 : $.$el,
        slideGroupCount: M.value
      }, h = fe(v), g = ce(v, h);
      (l || M.value !== v.slideGroupCount) && (o.trackStyle = g), Object.assign(u.value, o);
    }, vt = async (l = {
      shouldSetTrackStyle: !0
    }) => {
      !Y.value || !Y.value.$el || (i.value.widthDetection === le.manual && l.isWindowResize && await Re(), ke(
        l.shouldSetTrackStyle || i.value.widthDetection === le.manual && l.isWindowResize
      ), s.autoplay ? _(k.update) : R());
    }, te = (l) => {
      y == null || y.cancel(), y = Zt(() => vt(l), pr);
    }, Be = () => te({
      isWindowResize: !0
    }), gt = () => {
      i.value.autoplay && R(k.focused);
    }, ht = () => {
      i.value.autoplay && u.value.autoplaying === k.focused && _(k.blur);
    }, St = () => {
      const l = [], o = { ...i.value, ...u.value }, v = Oe({
        ...o,
        slideGroupCount: M.value
      }), h = J({
        ...o,
        slideGroupCount: M.value
      });
      for (let g = u.value.currentSlideGroupIndex; g < M.value + v; g++)
        if (u.value.lazyLoadedList.indexOf(g) < 0) {
          l.push(g);
          break;
        }
      for (let g = u.value.currentSlideGroupIndex - 1; g >= -h; g--)
        if (u.value.lazyLoadedList.indexOf(g) < 0) {
          l.push(g);
          break;
        }
      l.length > 0 ? (u.value.lazyLoadedList = u.value.lazyLoadedList.concat(l), n("lazyLoad", l)) : f && (clearInterval(f), f = null);
    }, yt = () => {
      var h;
      const l = (h = b.value) == null ? void 0 : h.querySelectorAll(
        ".v-slick-slide-group img"
      ), o = (l == null ? void 0 : l.length) || 0;
      let v = 0;
      l == null || l.forEach((g) => {
        const L = () => {
          ++v >= o && te();
        };
        if (!g.onclick)
          g.onclick = () => {
            var $;
            ($ = g.closest(".v-slick-slide-group")) == null || $.focus();
          };
        else {
          const $ = g.onclick.bind(g);
          g.onclick = (C) => {
            var B;
            $(C), (B = g.closest(".v-slick-slide-group")) == null || B.focus();
          };
        }
        if (g.onload)
          g.onload = L, g.onerror = () => {
            L(), n("lazyLoadError");
          };
        else {
          if (!i.value.lazyLoad) return;
          g.onload = () => {
            j(), p.push(setTimeout(te, i.value.speed));
          };
        }
      });
    }, Re = async () => (u.value.detectingWidth = !0, new Promise(
      (l) => setTimeout(() => {
        var o;
        Object.assign(_e.value, {
          width: `${(o = Ve.value) == null ? void 0 : o.offsetWidth}px`
        }), u.value.detectingWidth = !1, l();
      })
    )), wt = () => {
      const l = {
        ...i.value,
        ...u.value,
        slideGroupCount: M.value
      }, o = J(l), v = Oe(l);
      if (i.value.variableWidth) {
        let h = [], g = [];
        const L = [];
        Xe.value.forEach((C) => {
          let B = 0;
          C.forEach((he) => {
            var re;
            const { width: ne } = ((re = he.props) == null ? void 0 : re.style) || {};
            ne && (B = Math.max(B, ne));
          }), L.push(B), h.push(B);
        });
        for (let C = 0; C < o; C++)
          g.push(L[L.length - 1 - C]), h.push(L[L.length - 1 - C]);
        for (let C = 0; C < v; C++)
          h.push(L[C]);
        for (let C = 0; C < u.value.currentSlideGroupIndex; C++)
          g.push(L[C]);
        h = h.filter((C) => C), g = g.filter((C) => C);
        const $ = {
          width: `calc(${h.join(" + ")})`,
          left: `calc(${g.map((C) => `-${C}`).join(" + ")})`
        };
        if (i.value.centerMode) {
          const C = L[u.value.currentSlideGroupIndex];
          $.left = `calc(${g.map((B) => `-${B}`).join(" + ")} + (100% - ${C}) / 2 )`;
        }
        u.value.trackStyle = $;
      } else {
        const h = o + v + M.value, g = 100 / i.value.groupsToShow * h, L = 100 / h;
        let $ = -L * (o + u.value.currentSlideGroupIndex) * g / 100;
        i.value.centerMode && ($ += (100 - L * g / 100) / 2), u.value.slideGroupWidth = L + "%", u.value.trackStyle = {
          width: g + "%",
          left: $ + "%"
        };
      }
    }, pe = q(), Ve = q(), _e = q({}), b = q(), Y = q(), i = A(() => {
      const l = Ze(s);
      let o = { ...Jt, ...l };
      if (pe.value) {
        const v = s.responsive.find(
          (h) => h.breakpoint === pe.value
        );
        o = {
          ...o,
          ...v == null ? void 0 : v.settings
        };
      }
      return o.centerMode && (o.groupsToScroll > 1 && process.env.NODE_ENV !== "production" && console.warn(
        `centerMode is enabled: groupsToScroll should be 1; you are using ${o.groupsToScroll}`
      ), o.groupsToScroll = 1), o.fade && (o.groupsToShow > 1 && process.env.NODE_ENV !== "production" && console.warn(
        `fade is enabled: groupsToShow should be 1; you are using ${o.groupsToShow}`
      ), o.groupsToScroll > 1 && process.env.NODE_ENV !== "production" && console.warn(
        `fade is enabled: groupsToScroll should be 1; you are using ${o.groupsToScroll}`
      ), o.groupsToShow = 1, o.groupsToScroll = 1), o.slidesPerGroup > 1 && (o.variableWidth && process.env.NODE_ENV !== "production" && console.warn("slidesPerGroup is bigger than 1: variableWidth is disabled"), o.variableWidth = !1), o.vertical && o.rtl && (process.env.NODE_ENV !== "production" && console.warn("vertical mode is enabled: rtl is disabled"), o.rtl = !1), o;
    }), je = A(
      () => jt({
        ...i.value,
        ...u.value,
        slideGroupCount: M.value
      })
    ), Te = A(
      () => We({
        ...i.value,
        ...u.value,
        slideGroupCount: M.value
      })
    ), ve = A(() => {
      if (i.value.infinite)
        return Math.ceil(M.value / i.value.groupsToScroll);
      let l = Math.ceil(
        (M.value - i.value.groupsToShow) / i.value.groupsToScroll
      ) + 1;
      return !i.value.infinite && i.value.groupsToShow > 1 && i.value.centerMode && l++, l < 0 ? 0 : l;
    }), ge = q(d.default ? Ee(d.default()) : []), u = q({
      ...er(),
      currentSlideGroupIndex: i.value.initialGroupIndex
    }), Gt = A(
      () => u.value.currentSlideGroupIndex
    ), mt = A(() => i.value.groupsToShow), M = A(
      () => it(ge.value.length, i.value.slidesPerGroup)
    ), Xe = A(() => {
      const l = [], o = i.value.slidesPerGroup, v = M.value;
      for (let h = 0; h < v; h++) {
        const g = h * o, L = g + o;
        l.push(ge.value.slice(g, L));
      }
      return l;
    });
    return K(
      () => s.responsive,
      () => {
        G(), I();
      },
      { deep: !0 }
    ), K(
      i,
      (l, o) => {
        let v = !1;
        for (const h of Object.keys(i.value)) {
          if (!l.hasOwnProperty(h)) {
            v = !0;
            break;
          }
          if (!(typeof l[h] == "object" || typeof l[h] == "function") && l[h] !== o[h]) {
            v = !0;
            break;
          }
        }
        ke(v), u.value.currentSlideGroupIndex >= M.value && ee({
          message: "index",
          index: M.value - l.groupsToShow
        }), l.autoplay ? _(k.update) : R(k.paused);
      },
      {
        deep: !0
      }
    ), K(
      () => {
        var l;
        return ((l = d.default) == null ? void 0 : l.call(d)) || [];
      },
      (l) => {
        ge.value = Ee(l);
      }
    ), K(
      () => [
        u.value.listHeight,
        i.value.centerMode,
        i.value.centerPadding,
        i.value.vertical
      ],
      ([l, o, v, h]) => {
        let g = {
          height: "auto"
        };
        h && (g = {
          height: `${l}px`
        });
        let L;
        o ? h ? L = {
          padding: v + " 0px"
        } : L = {
          padding: "0px " + v
        } : L = {
          padding: "0"
        }, c.value = {
          ...c.value,
          ...Ze(g),
          ...L
        };
      }
    ), K(
      () => [
        i.value.infinite,
        u.value.currentSlideGroupIndex,
        i.value.groupsToShow,
        M.value
      ],
      ([l, o, v, h]) => {
        l || o <= h - v + 1 || U(ve.value - 1);
      }
    ), K(
      () => u.value.dragging,
      (l) => {
        b.value && (l ? (b.value.onmousemove = me, b.value.addEventListener(
          "touchmove",
          me,
          { passive: !1 }
        ), b.value.onmouseup = Pe, b.value.ontouchend = Pe, b.value.onmouseleave = Ae, b.value.ontouchcancel = Ae) : (b.value.onmousemove = null, b.value.removeEventListener(
          "touchmove",
          me
        ), b.value.onmouseup = null, b.value.ontouchend = null, b.value.onmouseleave = null, b.value.ontouchcancel = null));
      }
    ), K(
      () => ve.value <= u.value.currentSlideGroupIndex,
      (l) => {
        l && (u.value.currentSlideGroupIndex = 0);
      }
    ), r({
      goTo: U,
      next: () => {
        U(
          u.value.currentSlideGroupIndex + i.value.groupsToScroll
        );
      },
      prev: () => {
        U(
          u.value.currentSlideGroupIndex - i.value.groupsToScroll
        );
      },
      canGoNext: Te,
      canGoPrev: je,
      play: z,
      pause: R,
      autoPlay: _,
      slideGroupCount: M,
      currentSlideGroupIndex: Gt,
      currentGroupsToShow: mt,
      pageCount: ve
    }), bt(async () => {
      var l;
      window.addEventListener("resize", Be), i.value.widthDetection === le.manual && await Re(), ke(!0), j(), i.value.autoplay && _(k.update), i.value.lazyLoad === et.progressive && (f = setInterval(St, 1e3)), S = new ResizeObserver(() => {
        u.value.animating ? (te({ shouldSetTrackStyle: !1 }), p.push(setTimeout(() => te(), i.value.speed))) : te();
      }), S.observe(b.value), (l = b.value) == null || l.querySelectorAll(".v-slick-slide-group").forEach((o) => {
        o.onfocus = i.value.pauseOnFocus ? gt : null, o.onblur = i.value.pauseOnFocus ? ht : null;
      });
    }), Mt(() => {
      if (yt(), n("reInit"), i.value.lazyLoad) {
        const l = ze({
          ...i.value,
          ...u.value
        });
        l.length && (u.value.lazyLoadedList = u.value.lazyLoadedList.concat(l), n("lazyLoad", l));
      }
      j();
    }), Et(() => {
      window.removeEventListener("resize", Be), S == null || S.unobserve(b.value), T && clearTimeout(T), f && clearInterval(f), p.length && (p.forEach((l) => clearTimeout(l)), p = []), u.value.autoplayTimer && clearInterval(u.value.autoplayTimer);
    }), I(), wt(), n("init"), (l, o) => (O(), D("div", {
      ref_key: "vSlickCarouselRef",
      ref: Ve,
      class: "v-slick-carousel",
      style: Me(
        l.widthDetection === Se(le).manual ? u.value.detectingWidth ? { width: "100%" } : _e.value : {}
      )
    }, [
      se("div", {
        class: "v-slick-slider",
        dir: i.value.rtl ? "rtl" : "ltr"
      }, [
        i.value.arrows ? (O(), ie(Je, {
          key: 0,
          type: Se(P).previous,
          "center-mode": i.value.centerMode,
          infinite: i.value.infinite,
          "groups-to-show": i.value.groupsToShow,
          "slide-group-count": M.value,
          "current-slide-group-index": u.value.currentSlideGroupIndex,
          disabled: !je.value,
          onPrevious: pt
        }, {
          prevArrow: Le((v) => [
            oe(l.$slots, "prevArrow", ue(Ce(v)), void 0, !0)
          ]),
          _: 3
        }, 8, ["type", "center-mode", "infinite", "groups-to-show", "slide-group-count", "current-slide-group-index", "disabled"])) : Ie("", !0),
        se("div", {
          ref_key: "vSlickListRef",
          ref: b,
          class: de(["v-slick-list", { dragging: u.value.dragging }]),
          style: Me(c.value),
          onClick: F,
          onMousedown: Ne,
          onTouchstart: Ne,
          onKeydown: ut
        }, [
          Ot(sr, {
            ref_key: "vSlickTrackRef",
            ref: Y,
            "center-mode": i.value.centerMode,
            "center-padding": i.value.centerPadding,
            "raw-slide-groups": Xe.value,
            "css-ease": l.cssEase,
            "current-slide-group-index": u.value.currentSlideGroupIndex,
            "detecting-width": u.value.detectingWidth,
            fade: i.value.fade,
            "ignore-prefers-reduced-motion": i.value.ignorePrefersReducedMotion,
            infinite: i.value.infinite,
            "lazy-load": i.value.lazyLoad,
            "lazy-loaded-list": u.value.lazyLoadedList,
            "list-height": u.value.listHeight,
            rtl: i.value.rtl,
            "slide-group-count": M.value,
            "slide-group-height": u.value.slideGroupHeight,
            "slide-group-width": u.value.slideGroupWidth,
            "groups-to-scroll": i.value.groupsToScroll,
            "groups-to-show": i.value.groupsToShow,
            speed: i.value.speed,
            "track-style": u.value.trackStyle,
            "variable-width": i.value.variableWidth,
            vertical: i.value.vertical,
            onMouseenter: He,
            onMouseleave: at,
            onMouseover: He,
            onChildClick: nt
          }, null, 8, ["center-mode", "center-padding", "raw-slide-groups", "css-ease", "current-slide-group-index", "detecting-width", "fade", "ignore-prefers-reduced-motion", "infinite", "lazy-load", "lazy-loaded-list", "list-height", "rtl", "slide-group-count", "slide-group-height", "slide-group-width", "groups-to-scroll", "groups-to-show", "speed", "track-style", "variable-width", "vertical"])
        ], 38),
        i.value.arrows ? (O(), ie(Je, {
          key: 1,
          type: Se(P).next,
          "center-mode": i.value.centerMode,
          infinite: i.value.infinite,
          "groups-to-show": i.value.groupsToShow,
          "slide-group-count": M.value,
          "current-slide-group-index": u.value.currentSlideGroupIndex,
          disabled: !Te.value,
          onNext: ft
        }, {
          nextArrow: Le((v) => [
            oe(l.$slots, "nextArrow", ue(Ce(v)), void 0, !0)
          ]),
          _: 3
        }, 8, ["type", "center-mode", "infinite", "groups-to-show", "slide-group-count", "current-slide-group-index", "disabled"])) : Ie("", !0)
      ], 8, fr),
      i.value.dots ? (O(), ie(cr, {
        key: 0,
        "current-slide-group-index": u.value.currentSlideGroupIndex,
        infinite: i.value.infinite,
        "slide-group-count": M.value,
        "groups-to-scroll": i.value.groupsToScroll,
        "groups-to-show": i.value.groupsToShow,
        "page-count": ve.value,
        onDotClick: ct,
        onDotsOver: st,
        onDotsLeave: dt
      }, {
        customPaging: Le((v) => [
          oe(l.$slots, "customPaging", ue(Ce(v)), void 0, !0)
        ]),
        _: 3
      }, 8, ["current-slide-group-index", "infinite", "slide-group-count", "groups-to-scroll", "groups-to-show", "page-count"])) : Ie("", !0)
    ], 4));
  }
}), Sr = /* @__PURE__ */ De(vr, [["__scopeId", "data-v-22dfe058"]]);
export {
  et as LazyLoadType,
  k as PlayingType,
  P as SlideNavigation,
  N as SwipeDirection,
  Sr as VSlickCarousel,
  le as WidthDetection
};
//# sourceMappingURL=index.es.mjs.map
